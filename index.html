<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Vision HR & Payroll Suite</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Lucide (UMD) -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

  <style>
    /* Custom scrollbar for better look in Dark Mode */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #1f2937; }
    ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
    ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    body { font-family: 'Inter', sans-serif; }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
  <div id="root"></div>

  <!-- React / ReactDOM UMD -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel to transpile JSX in-browser (development only) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Firebase compat UMD (only used if you provide config via window.__firebase_config) -->
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>

  <!-- App code (Babel JSX) -->
  <script type="text/babel">
    const { useState, useEffect, useCallback } = React;
    const { createRoot } = ReactDOM;

    // minimal safe globals/fallbacks (same names used in original)
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    let firebaseConfig = null;
    try {
      firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config) ? JSON.parse(__firebase_config) : null;
    } catch (e) {
      console.warn("Invalid __firebase_config JSON:", e);
      firebaseConfig = null;
    }
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    // Initialize firebase compat only if config provided
    let fbApp = null, fbAuth = null, fbDb = null;
    if (firebaseConfig && window.firebase) {
      try {
        fbApp = firebase.initializeApp(firebaseConfig);
        fbAuth = firebase.auth();
        fbDb = firebase.firestore();
        console.log("Firebase initialized (compat).");
      } catch (e) {
        console.error("Firebase init error:", e);
        fbApp = fbAuth = fbDb = null;
      }
    } else {
      console.warn("No firebase config provided, running in local mode.");
    }

    const generateUniqueId = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
    const formatCurrency = (amount) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
    const formatDate = (timestamp) => {
      if (!timestamp) return 'N/A';
      // handle firebase Timestamp (toDate) or ISO/date string
      try {
        if (timestamp.toDate) return timestamp.toDate().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
        const d = new Date(timestamp);
        if (!isNaN(d)) return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
      } catch (e) {}
      return 'N/A';
    };

    // Icon component using lucide UMD
    const Icon = ({ name, size = 20, className = '' }) => {
      if (typeof lucide === 'undefined') return <span className={className}>*</span>;
      const IconComponent = lucide[name];
      if (!IconComponent) return <span className={className}>?</span>;
      try {
        const svg = IconComponent.toSvg ? IconComponent.toSvg({ width: size, height: size, class: className }) : IconComponent();
        return <i dangerouslySetInnerHTML={{ __html: svg }} />;
      } catch (e) {
        return <span className={className}>?</span>;
      }
    };

    // Keep Button/InputField/etc behavior similar to original
    const Button = ({ children, onClick, color = 'primary', icon, type = 'button', disabled = false, className = '' }) => {
      let baseStyle = 'px-4 py-2 rounded-lg font-semibold transition-all duration-200 shadow-lg flex items-center justify-center';
      let colorStyle = '';
      if (color === 'primary') { colorStyle = 'bg-blue-600 hover:bg-blue-700 text-white shadow-blue-500/50'; } 
      else if (color === 'danger') { colorStyle = 'bg-red-600 hover:bg-red-700 text-white shadow-red-500/50'; } 
      else if (color === 'secondary') { colorStyle = 'bg-gray-700 hover:bg-gray-600 text-gray-200 shadow-gray-700/50'; } 
      else if (color === 'success') { colorStyle = 'bg-green-600 hover:bg-green-700 text-white shadow-green-500/50'; }
      if (disabled) { colorStyle = 'bg-gray-500 text-gray-300 cursor-not-allowed shadow-none'; }
      return (<button type={type} onClick={onClick} className={`${baseStyle} ${colorStyle} ${className}`} disabled={disabled}>
          {icon && <Icon name={icon} className="mr-2" size={20} />}
          {children}
      </button>);
    };

    const InputField = ({ label, id, type = 'text', value, onChange, placeholder = '', required = false, themeClass = '' }) => (
      <div className="mb-4">
        <label htmlFor={id} className={`block text-sm font-medium ${themeClass.text}`}>{label} {required && <span className="text-red-500">*</span>}</label>
        <input type={type} id={id} name={id} value={value || ''} onChange={onChange} placeholder={placeholder} required={required} className={`mt-1 block w-full px-3 py-2 border rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm ${themeClass.input}`} />
      </div>
    );

    const SelectField = ({ label, id, value, onChange, options, required = false, themeClass = '' }) => (
      <div className="mb-4 relative">
        <label htmlFor={id} className={`block text-sm font-medium ${themeClass.text}`}>{label} {required && <span className="text-red-500">*</span>}</label>
        <select id={id} name={id} value={value || ''} onChange={onChange} required={required} className={`mt-1 block w-full pl-3 pr-10 py-2 border rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm ${themeClass.input} appearance-none`}>
          <option value="" disabled>Select {label}</option>
          {options && options.map(opt => (<option key={opt.value} value={opt.value}>{opt.label}</option>))}
        </select>
        <Icon name="ChevronDown" size={16} className={`absolute right-3 top-1/2 -translate-y-1/2 mt-2 ${themeClass.text} pointer-events-none`} />
      </div>
    );

    const Card = ({ children, className = '', themeClass = '' }) => (
      <div className={`p-6 rounded-xl shadow-2xl ${themeClass.card} ${className}`}>{children}</div>
    );

    const TabButton = ({ isActive, onClick, icon, children, themeClass }) => (
      <button onClick={onClick} className={`flex items-center space-x-2 px-4 py-2 rounded-lg transition-all duration-200 w-full ${
        isActive ? `${themeClass.tabActive} font-bold shadow-md` : `${themeClass.tabInactive} hover:${themeClass.tabHover}`
      }`}>
        <Icon name={icon} size={20} />
        <span className="hidden sm:inline">{children}</span>
      </button>
    );

    const Modal = ({ isOpen, title, children, onClose, themeClass, modalData }) => {
      if (!isOpen) return null;
      return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-70 backdrop-blur-sm" onClick={onClose}>
          <Card themeClass={themeClass} className="w-full max-w-md" onClick={(e) => e.stopPropagation()}>
            <h3 className={`text-xl font-bold mb-4 ${themeClass.text}`}>{title}</h3>
            <div className="mb-6">{children}</div>
            {modalData?.type !== 'ConfirmDelete' && (<div className="flex justify-end"><Button onClick={onClose} color="secondary">Close</Button></div>)}
            {modalData?.type === 'ConfirmDelete' && (
              <div className="mt-4 flex justify-end space-x-3">
                <Button onClick={onClose} color="secondary">Cancel</Button>
                <Button onClick={() => { modalData.data.onConfirm(); onClose(); }} color="danger">Delete</Button>
              </div>
            )}
          </Card>
        </div>
      );
    };

    // App (keeps original structure, minimal changes for compat)
    const App = () => {
      const [userId, setUserId] = useState(null);
      const [isAuthReady, setIsAuthReady] = useState(false);
      const [employees, setEmployees] = useState([]);
      const [ledgers, setLedgers] = useState([]);
      const [attendance, setAttendance] = useState([]);
      const [activeTab, setActiveTab] = useState('Dashboard');
      const [modal, setModal] = useState({ isOpen: false, type: null, data: null });
      const [theme, setTheme] = useState('dark');

      const themes = {
        dark: { bg: 'bg-gray-900', sidebar: 'bg-gray-800', text: 'text-gray-100', textSecondary: 'text-gray-400', card: 'bg-gray-800 border border-gray-700', input: 'bg-gray-700 border-gray-600 text-white', tabActive: 'bg-blue-600 text-white', tabInactive: 'text-gray-400', tabHover: 'bg-gray-700', accent: 'text-blue-400', },
        light: { bg: 'bg-gray-100', sidebar: 'bg-white', text: 'text-gray-800', textSecondary: 'text-gray-500', card: 'bg-white shadow-xl', input: 'bg-gray-50 border-gray-300 text-gray-800', tabActive: 'bg-blue-500 text-white', tabInactive: 'text-gray-600', tabHover: 'bg-gray-200', accent: 'text-blue-600', },
        ocean: { bg: 'bg-blue-900', sidebar: 'bg-blue-800', text: 'text-blue-100', textSecondary: 'text-blue-300', card: 'bg-blue-800 border border-blue-700', input: 'bg-blue-700 border-blue-600 text-white', tabActive: 'bg-teal-500 text-white', tabInactive: 'text-blue-200', tabHover: 'bg-blue-700', accent: 'text-teal-400', }
      };
      const themeClass = themes[theme] || themes.dark;

      // Auth setup using compat if available, otherwise fallback to local pseudo-auth
      useEffect(() => {
        if (!fbAuth) { console.error("Firebase Auth not initialized (compat). Running local fallback."); setIsAuthReady(true); setUserId(localStorage.getItem('vision_local_user') || crypto.randomUUID()); localStorage.setItem('vision_local_user', localStorage.getItem('vision_local_user') || userId || crypto.randomUUID()); return; }
        const setupAuth = async () => {
          try {
            if (initialAuthToken) { await fbAuth.signInWithCustomToken(initialAuthToken); } 
            else { await fbAuth.signInAnonymously(); }
          } catch (error) { console.error("Auth Error:", error); }
        };
        const unsubscribe = fbAuth.onAuthStateChanged((user) => {
          if (user) { setUserId(user.uid); } 
          else { setUserId(crypto.randomUUID()); }
          setIsAuthReady(true);
        });
        setupAuth();
        return () => unsubscribe && unsubscribe();
      }, []);

      // Firestore snapshots (compat) or localStorage fallback
      useEffect(() => {
        if (!isAuthReady || !userId) return;
        if (!fbDb) {
          // load from localStorage keys
          const e = JSON.parse(localStorage.getItem(`vision_local_employees`) || "[]");
          const l = JSON.parse(localStorage.getItem(`vision_local_ledgers`) || "[]");
          const a = JSON.parse(localStorage.getItem(`vision_local_attendance`) || "[]");
          setEmployees(e);
          setLedgers(l);
          setAttendance(a);
          return;
        }
        const baseCollectionPath = `artifacts/${appId}/users/${userId}`;
        try {
          const empRef = fbDb.collection(`${baseCollectionPath}/employees`);
          const ledRef = fbDb.collection(`${baseCollectionPath}/ledgers`);
          const attRef = fbDb.collection(`${baseCollectionPath}/attendance`);
          const unsubE = empRef.onSnapshot(snap => setEmployees(snap.docs.map(d => ({ id: d.id, ...d.data() }))), err => console.error(err));
          const unsubL = ledRef.onSnapshot(snap => setLedgers(snap.docs.map(d => ({ id: d.id, ...d.data() }))), err => console.error(err));
          const unsubA = attRef.onSnapshot(snap => setAttendance(snap.docs.map(d => ({ id: d.id, ...d.data() }))), err => console.error(err));
          return () => { unsubE(); unsubL(); unsubA(); };
        } catch (e) {
          console.error("Firestore snapshot setup error:", e);
        }
      }, [isAuthReady, userId]);

      // save/delete document helpers (compat or local)
      const saveDocument = useCallback(async (collectionName, data, id = null) => {
        if (!fbDb) {
          // local storage fallback
          const key = `vision_local_${collectionName}`;
          const arr = JSON.parse(localStorage.getItem(key) || "[]");
          if (id) {
            const idx = arr.findIndex(x => x.id === id);
            if (idx >= 0) arr[idx] = { ...arr[idx], ...data, id };
            else arr.push({ ...data, id });
          } else {
            const newId = generateUniqueId();
            arr.push({ ...data, id: newId });
          }
          localStorage.setItem(key, JSON.stringify(arr));
          // update state shortcuts
          if (collectionName === 'employees') setEmployees(JSON.parse(localStorage.getItem(key)));
          if (collectionName === 'ledgers') setLedgers(JSON.parse(localStorage.getItem(key)));
          if (collectionName === 'attendance') setAttendance(JSON.parse(localStorage.getItem(key)));
          return true;
        }
        try {
          const collectionPath = `${fbDb.app.name ? '' : ''}${collectionName}`; // not used directly; using base collection earlier
          const fullPath = `artifacts/${appId}/users/${userId}/${collectionName}`;
          if (id) {
            await fbDb.collection(fullPath).doc(id).set(data, { merge: true });
          } else {
            await fbDb.collection(fullPath).add(data);
          }
          return true;
        } catch (error) {
          console.error(`Error saving document to ${collectionName}:`, error);
          setModal({ isOpen: true, type: 'Error', data: { message: `Failed to save ${collectionName}: ${error.message}` } });
          return false;
        }
      }, [fbDb, userId]);

      const deleteDocument = useCallback(async (collectionName, id) => {
        if (!fbDb) {
          const key = `vision_local_${collectionName}`;
          const arr = JSON.parse(localStorage.getItem(key) || "[]").filter(x => x.id !== id);
          localStorage.setItem(key, JSON.stringify(arr));
          if (collectionName === 'employees') setEmployees(arr);
          if (collectionName === 'ledgers') setLedgers(arr);
          if (collectionName === 'attendance') setAttendance(arr);
          return true;
        }
        try {
          const fullPath = `artifacts/${appId}/users/${userId}/${collectionName}`;
          await fbDb.collection(fullPath).doc(id).delete();
          return true;
        } catch (error) {
          console.error(`Error deleting document from ${collectionName}:`, error);
          setModal({ isOpen: true, type: 'Error', data: { message: `Failed to delete ${collectionName}: ${error.message}` } });
          return false;
        }
      }, [fbDb, userId]);

      // EmployeeManagement component (kept similar)
      const EmployeeManagement = () => {
        const [formData, setFormData] = useState({});
        const [isEditing, setIsEditing] = useState(false);
        const [searchTerm, setSearchTerm] = useState('');

        const handleChange = (e) => { const key = e.target.id || e.target.name; setFormData({ ...formData, [key]: e.target.value }); };
        const handleSubmit = async (e) => {
          e.preventDefault();
          const success = await saveDocument('employees', {
            ...formData,
            salary: parseFloat(formData.salary || 0),
            dateJoined: new Date().toISOString(),
          }, isEditing ? formData.id : null);
          if (success) {
            setFormData({});
            setIsEditing(false);
            setModal({ isOpen: true, type: 'Success', data: { message: `Employee ${isEditing ? 'updated' : 'added'} successfully.` } });
          }
        };
        const handleEdit = (employee) => { setFormData(employee); setIsEditing(true); };
        const handleDelete = async (id) => {
          setModal({
            isOpen: true,
            type: 'ConfirmDelete',
            data: {
              message: "Are you sure you want to delete this employee? This action cannot be undone.",
              onConfirm: async () => {
                const success = await deleteDocument('employees', id);
                if (success) setModal({ isOpen: true, type: 'Success', data: { message: 'Employee deleted successfully.' } });
                else setModal({ isOpen: true, type: 'Error', data: { message: 'Failed to delete employee.' } });
              }
            }
          });
        };

        const filteredEmployees = (employees || []).filter(emp =>
          (emp.name || '').toString().toLowerCase().includes((searchTerm || '').toLowerCase()) ||
          (emp.role || '').toString().toLowerCase().includes((searchTerm || '').toLowerCase())
        ).sort((a, b) => new Date(b.dateJoined || 0) - new Date(a.dateJoined || 0));

        const employeeRoles = [
          { value: 'Manager', label: 'Manager' },
          { value: 'Developer', label: 'Developer' },
          { value: 'HR', label: 'HR Specialist' },
          { value: 'Sales', label: 'Sales Representative' },
          { value: 'Other', label: 'Other' },
        ];

        return (
          <div className="space-y-6">
            <Card themeClass={themeClass}>
              <h2 className={`text-2xl font-bold mb-4 ${themeClass.accent}`}>{isEditing ? 'Edit Employee' : 'Add New Employee'}</h2>
              <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <InputField label="Full Name" id="name" value={formData.name} onChange={handleChange} required themeClass={themeClass} />
                <SelectField label="Role" id="role" value={formData.role} onChange={handleChange} options={employeeRoles} required themeClass={themeClass} />
                <InputField label="Email" id="email" type="email" value={formData.email} onChange={handleChange} themeClass={themeClass} />
                <InputField label="Monthly Salary (USD)" id="salary" type="number" value={formData.salary} onChange={handleChange} required themeClass={themeClass} />
                <div className="md:col-span-2 flex justify-end space-x-3">
                  {isEditing && (<Button type="button" onClick={() => { setIsEditing(false); setFormData({}); }} color="secondary">Cancel Edit</Button>)}
                  <Button type="submit" color="primary" icon={isEditing ? 'Save' : 'UserPlus'}>{isEditing ? 'Save Changes' : 'Add Employee'}</Button>
                </div>
              </form>
            </Card>

            <Card themeClass={themeClass}>
              <h2 className={`text-2xl font-bold mb-4 ${themeClass.accent}`}>Employee Directory ({employees.length})</h2>
              <InputField label="Search Employee" id="search" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Name or Role" themeClass={themeClass} />
              <div className="overflow-x-auto mt-4">
                <table className="min-w-full divide-y divide-gray-700">
                  <thead>
                    <tr className={`${themeClass.sidebar}`}>
                      <th className={`px-6 py-3 text-left text-xs font-medium uppercase tracking-wider ${themeClass.textSecondary}`}>Name</th>
                      <th className={`px-6 py-3 text-left text-xs font-medium uppercase tracking-wider ${themeClass.textSecondary}`}>Role</th>
